# ハードウェア実験第6-7回レポート

## このアーカイブについて
- div32: 32ビットの除算器
- div32p2: 32ビットの除算器(パイプライン化)
- divider8191: 8191で割る除算器
という3つのモジュールが課題の解答として含まれていますが、そのほかにも
- div32p2_32_0: パイプライン化されたときに計算を前半に集中させたもの
- div32p2_0_32: パイプライン化されたときに計算を後半に集中させたもの

## div32p2_32_0 の謎ゼロ Delay

前半後半のさまざまな割合を試した結果、

| 前半 | 後半 | Utilization | Total Delay |
|------|------|-------------|-------------|
| 0    | 32   | 2677        | 101.985     |
| 8    | 24   | 2096        | 76.627    |
| 16   | 16   | 1423        | 50.999     |
| 24   | 8    | 663         | 25.462    |
| 32   | 0    | 82          | 0.8       |

前半に計算を集中させるほど、後半がすぐ結果ができてしまうことが確認できたが、
前半が後半より遅延される場合、次のクロックサイクルに間に合うはずがないが、
合成の結果がこうなっているのはなぜか。自分もよくわからない。

## div32
Total Delay: 101.985

+----------+------+---------------------+
| Ref Name | Used | Functional Category |
+----------+------+---------------------+
| LUT6     | 1296 |                 LUT |
| LUT4     |  713 |                 LUT |
| LUT5     |  571 |                 LUT |
| LUT3     |  485 |                 LUT |
| CARRY4   |  416 |          CarryLogic |
| LUT2     |  159 |                 LUT |
| LUT1     |    1 |                 LUT |
+----------+------+---------------------+

## div32p2 
Total Delay: 50.999

+----------+------+---------------------+
| Ref Name | Used | Functional Category |
+----------+------+---------------------+
| LUT6     |  630 |                 LUT |
| LUT4     |  401 |                 LUT |
| LUT5     |  323 |                 LUT |
| CARRY4   |  208 |          CarryLogic |
| LUT3     |  180 |                 LUT |
| LUT2     |  128 |                 LUT |
| FDRE     |  112 |        Flop & Latch |
| FDCE     |   96 |        Flop & Latch |
| LUT1     |   17 |                 LUT |
+----------+------+---------------------+

## divider8191
Total Delay: 7.017

+----------+------+---------------------+
| Ref Name | Used | Functional Category |
+----------+------+---------------------+
| LUT2     |   51 |                 LUT |
| CARRY4   |   28 |          CarryLogic |
+----------+------+---------------------+

実装の説明

この記事を参考にしました。https://arxiv.org/pdf/2008.08654

```verilog
assign q = (((((x + 1) >> 13) + x + 1) >> 13) + x + 1) >> 13;
assign r = (x + q) & 8191;
```

数学的帰納法より、各ステップで最大のエラーが (q^n - 1) / q - 1 のように書けることが記事の Section 4 に示されたが、それを実際に計算してたしかめると、>> 13 とは 2^13 で割ることを意味するので、x / 2^13 - 1 の代わりに x + 1 / 2^13 による計算のエラーを考えるということである。

　>> 13 シフトすると、最大のエラーが 8192、つまり 13ビットのエラーが生じることがわかる。
　>> 13 シフトすると、最大のエラーが 1、つまり 1 ビットのエラーが生じることがわかる。
　>> 13 シフトすると、エラーが消える。

余りの方は x = q * 8191 + r であることから
x + q = q * 8192 + r となるので、8192 で13ビット左シフトするので、& 8191 すると下位12ビットのrが取り出せる。
